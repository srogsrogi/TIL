# Langchain



## 선수 지식

- Python 기초 문법 및 OOP 이해
- ML/DL 및 NLP/LLM 기초 개념 이해
- Agent 동작 방식 이해
- conda 가상 환경 등을 통한 코드 실행 환경 재현
- 환경 변수를 통한 API key 관리법 이해



## 학습 목표

- Langgraph, Langchain, Langsmith가 이루고 있는 **LLM 프레임워크 생태계**와 각 모듈의 역할에 대해 설명할 수 있다.
- Langchain 라이브러리를 활용하여 **model과 agent를 각각 실행**할 수 있다.
- 웹 검색 등 필요한 **tool을 정의하고 agent에 전달**하여 활용할 수 있다.
- 사용자와 AI의 **대화 기록을 단기 메모리 또는 DB에 저장**할 수 있다.
- **middleware의 개념을 이해**하고 필요한 middleware의 활용법을 탐색할 수 있다.



## Warm-up

- 수업을 듣거나 AI에 대해 이야기할 때, **Langchain**이라는 키워드가 시도 때도 없이 등장했을 겁니다.
- 언어 모델.. 체인.. 대충은 알 수도 있고, SSAFY 실습 때 `Langchain`으로 LLM을 호출해보셨을 수도 있지만.. 거대한 **프레임워크의 생태계**를 제대로 이해하지는 못하셨을 거라 생각합니다.
- 오늘은 `Langgraph`, `Langchain`, `Langsmith`의 기능들을 유기적으로 연결해서 이해하고, 특히 `Langchain` 라이브러리를 활용하여 **Agent**를 구축해보겠습니다.
- 오늘 수업에서도, 복습하거나 실제로 개발하실 때도 항상 최신 버전의 **공식 문서와 수업 자료**를 기반으로 코드를 작성하셔야 합니다.
  - Langchain 개발이 빠르게 이뤄지며 버전 업데이트 주기가 잦고, 상위 버전의 기능상 이점이 매우 크기 때문에 반드시 **1.0 이상의 최신 버전을 활용**해야 합니다. 의존성이 민감하니 `requirements.txt` 버전 고정도 필수!
  - GPT한테 던져 주면 아~무리 프롬프트를 잘 줘도 다른 버전의 코드들을 뒤섞어서 내놓기 때문에 **반드시 오류가 발생**합니다.
  - AI가 체인 내부의 세부적인 동작까지 개발자의 의도에 맞게 설계하기 어렵습니다.
  - 반드시 각 모듈의 작동과 각 파라미터의 역할을 **이해하고 직접 코드를 작성**해야 함을 명심하세요.

- 이론 수업에서는 Langchain, Langgraph, Langsmith를 각각 가볍게 이해하고
- 실습에서는 Langchain의 주요 기능들을 코드로 구현해보겠습니다.



## 이론

### Langchain

#### 개념

- LLM을 활용하여 자동화된 작업을 수행하는 **Agent를 만드는** 라이브러리



#### 기능

- 사용할 **모델 초기화** 설정
  - 로컬 LLM, LLM API 중 **원하는 모델을 선택**하고 객체화
  - 모델 별 파라미터 설정
- `invoke()` 메서드를 통해 **모델 또는 에이전트를 실행**
  - 모델은 단발성 요청 - 응답 처리
  - 에이전트는 목표를 설정하고 **Chain을 실행**하여 최종 응답을 반환
    - **Chain : 도구 사용 및 LLM 호출을 연결하여 실행하는 워크플로우**
- 정의된 **tool**을 에이전트에게 전달
  - 커스텀 tool 사용
  - 외부 서비스가 제공하는 tool 통합
  - LLM 벤더가 제공하는 tool 바인딩
    - 이 방법은 **사용을 지양**합시다. 자세한 내용은 실습에서 다루겠습니다!

- 후술할 메모리 관리, middleware 등 **Langgraph의 일부 기능도 상속받아 사용 가능**



### Langgraph

#### 개념

- Langchain Agent와 tool을 함께 관리하고 최적화하는 **그래프 기반** 오케스트레이션 시스템

  - node : **에이전트** 또는 에이전트가 실행하는 tool / model의 구현체

  - edge : 작업 흐름을 연결하는 데이터 전달선

  - state : 각 노드의 작업 실행 결과 발생하는 **중간 결과**로서, 다음 작업으로 전달됨

- 작업 단위를 Langchain보다 더 세부적으로 **모듈화**하고 분배하는 설계
  - 이전 수업(Docker containerization)에서 배웠던 **선언형 패러다임이나 MSA**과 같은 맥락에서 이해하셔도 좋습니다.
    - Container orchestration에서는 state를 유지하는 것 자체가 시스템의 목표였지만
    - Langgraph의 LLM orchestration에서는 에이전트가 세운 목표를 수행하기 위해 state를 활용한다고 보시면 됩니다.




#### 기능

- node, edge, state에 대한 정의를 통해 **그래프 구성**

- **각 node는 Langchain 에이전트**로서 각자 정의된 역할을 수행

- 메모리 관리

  - 단기 메모리 : **세션 내**에서의 대화 기록을 저장하고 맥락을 유지하는 임시 메모리

  - 장기 메모리 : 사용자 데이터를 저장하고 활용하여 **장기적인 맥락**을 유지하는 영속적인 메모리

- node의 실행 결과인 state가 다음 node에 전달되기 전 **middleware 개입** 가능
  - 출력 결과 필터링, 전처리, 기타 agent 동작 관련 세부 설정

### Langsmith

#### 개념

- Langchain Agent 실행을 기록하고 분석하는 **Observability 플랫폼**

![](./langsmith.png)



#### 기능

- tracing : 각 요청에 대한 Agent 실행 기록 추적 및 시각화
  - 사용자 및 AI의 입출력
  - 워크플로우 실행 과정
  - 각 과정에서의 토큰 사용량, 지연 시간, 과금량 등 리소스 소모량
  - 오류 로그 및 디버깅 정보 등
- monitoring : 프로젝트 내 전체적인 Agent 실행 관련 지표 실시간 제공
  - 일별·모델별 사용량 및 과금액
  - 도구별 호출 횟수 등
- 기타 실행 최적화를 위한 다양한 분석 툴 제공



## 실습

- https://github.com/srogsrogi/TIL/blob/master/Lesson/langchain/langchain_practice/langchain_guide.ipynb
- Langchain을 활용한 에이전트 구현 및 실행 코드를 강사와 함께 **손으로 작성하는 실습**을 진행합니다.
  - 일반적인 로직 구현이나 대부분의 프레임워크 사용 시 GPT의 도움을 받아 코드를 작성할 수 있으나
  - Langchain은 버전이 안정화되고 사용법이 표준화되기 전까지는 손코딩이 필수적으로 요구됩니다.
- **Langgraph는 생략!** 오늘은 Langchain을 통해 각 에이전트의 작동방식을 익히는 것을 목표로 합니다.
  - Langgraph는 프로젝트 내에서 멀티 에이전트 설계가 필요해지면 다시 배워서 사용합시다.
  - 문법은 꽤 다르지만 node 및 tool 설계는 Langchain과 같기 때문에 처음보단 배울만 할 겁니다.

- 실습 중간중간, 그리고 마지막에 **Langsmith**에 접속하여 로그도 확인해보고, 서비스 개발 및 최적화 시 어떻게 활용할지 상상해봅시다.



## Wrap-up Quiz

- Langgraph, Langchain, Langsmith의 기능 및 역할은 각각 무엇인가요?
- ChatGPT 서비스에서 단기 메모리 및 장기 메모리가 어떻게 활용되고 있나요?
- middleware 조작을 통해 할 수 있는 작업이 무엇이 있을까요?



## 강의 마무리

- 실습 위주의 수업인 만큼, 직접 구현해본 기능과 메서드들이 어떤 상황에서 활용되어야 하는지를 함께 떠올리며 복습합시다.
- 기술이 빠르게 발전하면서, 실시간으로 쏟아지는 좋은 서비스들의 Docs를 읽고 활용할 수 있는 능력이 더욱 중요해지고 있습니다.
  - Langchain Docs는 적절한 코드 예시와 함께 잘 구조화되어 있어 문서 독해력을 키울 수 있는 아주 좋은 기회가 됩니다.
  - Agentic LLM을 직접 개발할 일이 있다면, 다른 기술을 배우고 적용할 때보다 훨씬 오래 걸리더라도 진득하게 공부해보시길 추천합니다.
  - 물론 공부 대충 하고 딸깍딸깍 복붙을 시도하더라도, 어차피 절대 GPT가 코드를 작성해줄 수 없다는 걸 곧 깨닫게 되긴 합니다.. 화이팅합시다.

- 제가 써놓고 이런 말 하기 좀 그렇지만.. 수업일 기준으로도 Langchain 1.0이 출시된 지가 2주 정도밖에 안 돼서, 한동안은 `langchain_guide.ipynb` 만큼 괜찮은 레퍼런스 구하기가 쉽지 않을 겁니다. 개발하실 때 공식 문서와 함께 적극적으로 활용하세요!



## 수강생 피드백

- 수강생 1

  LANGCHAIN 1.0 이 출시된 지 한달도 되지 않아서, 시중의 어떤 교재로도 1.0을 다룬 코드를 찾아볼 수 없었는데 이번 수업을 통해서 다루게 되어서 영광이었습니다. 랭체인이랑 랭그래프, 랭스미스를 전체적으로 싹 훑으며 숲을 바라보고, 세부 코드와 주석을 클론 코딩하며 나무를 바라보는 수업 구조가 아주 혁신적이었습니다. 개인 학습이 가능하도록 세부적인 주석을 달아둔 점은 혁명적이었고, 덕분에 복잡한 개념도 체계적으로 이해할 수 있어서 너무 좋았습니다.

- 수강생 2

  상세하게 설명해주셔서 제가 계속 감을 못 잡고 있던 음.. 이건 코드로 어떻게 쓰는 거지? 어떻게 돌아가는거지?에 대한 답을 얻을 수 있었습니다. 특히 타자로 직접 치면서 주석을 다니까 확실하게 이해할 수 있었던 것 같고, 앞으로 데이터나 AI 쪽 공부할 때는 쓰면서 생각해보는 게 기억에도 잘 남고 이해하기 좋겠다는 생각이 들었습니다! 언제나 설치부터 도와주셔서 큰 도움이 됩니다. 복습하면서 직접 활용할 수 있게끔 해보겠습니다 ㅎㅎ

- 수강생 3

  이 강의는 미쳤읍니다. 이 강의로 얻을 수 있는 것

  - AI에 의존하지 않고 docs를 참고하면서 개발하는 태도를 정립할 수 있어요
  - 코드 구성과 로직에 스토리가 있어서 이해가 잘돼요. 단순히 "이 기능은 이렇게 합니다"가 아니라 "~~이런 이유로 이렇게 되고 이렇게 써볼수 있어요"라는 설명이기 때문에 더 기억에 잘 남고 재밌어요
  - 코드 블록마다 마크다운이나 주석 설명이 친절하고 자세해서 좋아요
  - 랭체인, 랭그래프의 장점에 대해 명확하게 설명을 해준 점도 좋았어요



## 소감

- Langchain 1.0이 나온지 진짜 얼마 안 돼서, 세상에 없는 가치를 만든 것 같아서 특히 보람있었음
- Docs 읽는 훈련이 많이 됐음
- 해커톤 준비하면서 RAGFlow 써보고 있는데, 점점 코드 구현이 별로 필요 없어질 것 같은 생각이 좀 들긴 한다.
