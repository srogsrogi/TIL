# 브랜치



## 주요 개념

### Commit

- 특정 시점의 프로젝트 상태와 메타데이터를 담고 있는 객체
- 이전 커밋과의 차이, 변동된 내역을 연쇄적으로 저장



### Branch

- 특정 커밋을 가리키는 **포인터**
  - branch라는 이름 때문에 혼동하기 쉬움. 가지 전체를 칭하는게 아님을 유의할 것
- 작업 라인을 분리해 독립적으로 개발할 수 있도록 함



### HEAD

- 현재 작업의 기준이 되는 **커밋! 커밋! 커밋!**을 가리키는 **포인터**

- 사용자는 switch(또는 checkout) 명령을 통해 HEAD를 옮길 수 있음

  - 브랜치 이름을 기준으로 `switch`하더라도, 내부적으로는 HEAD가 branch를 가리키는 참조를 거쳐 그 branch의 마지막 **커밋**으로 이동한다.

  

## Branch의 작동 원리

- 새 브랜치를 만들면 현재 HEAD가 가리키는 커밋을 기준으로 새 포인터 생성

- 브랜치에서 커밋을 만들면 그 브랜치 포인터가 한 칸 앞으로 이동

- 브랜치를 이동(`switch`, `checkout`)하면 HEAD가 다른 포인터를 바라봄

- HEAD 커밋이 속하지 않은 브랜치의 커밋들은 보이지 않지만, 실제로는 히스토리 전체에 존재함
  - `git log --all` 명령어로 현재 HEAD 위치와 상관 없이 전체 히스토리를 볼 수 있음



## Merge

- 서로 다른 브랜치의 변경 내용을 특정 커밋에서 하나로 합치는 것

- 병합 직후에는 병합된 커밋을 공유하는 모든 branch의 히스토리가 보인다.

  - 왜? HEAD는 그 커밋에 있으니까!
    - 병합된 커밋을 포함하는 여러 branch가 있고, 그 모든 branch들의 히스토리를 볼 수 있다.
    - switch를 통해 그 중 하나의 branch를 선택해도 마찬가지.

  

### Fast-Forward merge

- FF merge
- 대상 브랜치가 다른 브랜치보다 뒤처져 있지만, 갈라지지는 않은 경우에 수행하는 병합
  - 즉, 병합하려는 두 브랜치 중 한쪽 브랜치가 다른 브랜치의 조상일 때만 ff merge가 가능하다
  - 보통 dev - main의 관계
- 해당 브랜치의 포인터를 앞서간 브랜치의 커밋으로 이동시킴
- 새 커밋을 생성하지 않음



### 3-way merge

- non-FF merge
- 두 브랜치가 서로 다른 커밋에서 갈라진 경우에 수행하는 병합
- 공통 조상(두 브랜치가 갈라지기 전 마지막으로 공유한 커밋)이 되는 가장 가까운 커밋을 찾아서 그 커밋을 기준으로 병합
- 새 커밋을 생성하며 병합함
- conflict(충돌)이 잦음
  - 같은 파일의 같은 line에 대해 서로 다른 변동 사항이 있는 경우 발생
- 병합 자체를 커밋으로 기록하기 위해 ff merge가 가능한 경우에도 non-ff merge를 쓰기도 함



### Detached commit

- HEAD가 브랜치를 거치지 않고 특정 커밋 해시를 가리키는 상태에서 만들어진 커밋
- 특정 브랜치에 속하지 않고 떠있는 상태로 존재함
  - 다른 브랜치로 이동하는 순간 `git log`로도 안 보이는 상태가 됨
  - `git reflog`로 조회 가능
- 실험적인 변경을 하는 경우 또는 임시 테스트에 유용함
- 그러나 Garbage Collection의 정리 대상이므로 보존을 원할 경우 브랜치에 연결해줘야 함