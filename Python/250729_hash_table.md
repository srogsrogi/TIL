# Hash table

- key와 value를 짝지어 저장하는, 파이썬 내부적으로 사용하는 자료 구조
- 초기에는 고정된 크기의 비어 있는 배열(버킷)
- 해시함수가 실행되면, 배열 안에 고정된 길이의 정수값을 key로 하는 key-value 쌍을 저장
  - 해시함수의 결과(정수)를 기반으로 버킷 index(배열의 어디에 저장될지)를 결정
  - python의 경우 프로세스가 새로 시작될 때마다 설정되는 random seed가 달라지기 때문에 같은 데이터라도 매번 해시값이 달라지고 당연히 버킷 배치도 달라짐



## 원리

- key를 해시함수를 통해 해시 값으로 변환
- 변환된 해시 값을 index로 삼아 데이터를 저장하거나 조회
- 이를 통해 검색, 삽입, 삭제를 매우 빠르게 수행

### 쉽게 말하면..

- 어떤 객체(자료형)를 정의하는 클래스에서 `__hash__` 메서드를 정의하고
- 그 안에 값을 어떻게 해시 값으로 변환할지를 정의하는지가 정해져있는 거구나!



## 질문/답변

- **Q1. 해시값에 따라 버킷 인덱스가 정해진다면, 여러 해시값이 생성됐을 때 같은 인덱스에 배치될 수도 있는 거 아닌가?**

  - 맞음. 그걸 collisions(충돌)이라고 부르고, 충돌이 일어났을 때 그냥 값을 덮어버리면 당연히 안 되니까 버킷 인덱스가 결정될 때 충돌을 처리하는 로직도 포함되어 있음

    

- **Q2-1. 작은 정수는 난수보정 없이 그 값 그대로 해시값이 된다며? 그럼 버킷 인덱스도 어떤 함수를 통해서 동일한 값이 계속 나올텐데 그럼 그 key-value 쌍의 위치(pop될 순서)는 미리 예측할 수 있는 거 아냐? 예를 들어 136이 해시테이블의 가장 앞쪽의 버킷인덱스에 저장된다면 걔는 무조건 맨 앞에 나오는 거잖아.**

  - 접근 자체는 맞고 실제로 그럴 때도 있음(충돌이 없고 배열 구조가 변하지 않는 경우)
  - 그런데 두 가지 이유로 작은 정수라고 하더라도 고정된 버킷 인덱스가 보장되지 않음
    - 저장된 해시값들이 많아져서 충돌이 발생하는 경우, 버킷 인덱스가 바뀔 수 있음
    - 해시값들이 많아짐에 따라 충돌이 발생할 가능성이 늘어나면, 버킷 배열의 크기 자체를 늘리는 resize가 일어나고 개별 요소의 버킷 인덱스도 바뀔 수 있음
  - 그리고 어차피 개발자 입장에서 특정 값의 버킷 인덱스를 일일이 알고서 코딩할 게 아니니까 버킷 인덱스가 고정되는 경우가 있다고 하더라도 실질적으론 의미가 없지.

- **Q2-2. resize라는 건 해시 테이블에 저장된 값들이 많아질수록 충돌이 기하급수적으로 늘어나기 때문에 어느 임계점을 넘어가면 배열 크기 자체를 키워서 성능을 유지하는 알고리즘이겠지?**

  - 맞음. 저장된 요소 수가 (전체 버킷 수 *load factor)보다 높아지거나, 내부적으로 삭제된 엔트리가 충분히 많아지는 경우 resize가 일어남
    - load factor는 0~1 사이의 값이며 일반적으로 0.66~0.75정도를 씀

- **Q2-3. 조건이 생각보다 단순하네? 실제 충돌이 일어나는 횟수는 난수보정 때문에 실행시마다 달라지니까, 단순히 버킷 배열의 점유율만을 가지고 resize 조건을 설정할 수밖에 없는 거구나?**

  - 그치. 충돌횟수는 비결정적이라 미리 예측할 수 없으니까 그렇게 하는 거.

- **Q2-4. resize의 동작 방식은? 새 배열을 만들고 기존에 저장된 값들을 전부 재배치해야 하나?**

  - 맞음. 먼저 새로운 크기의 빈 버킷 배열을 생성(보통 2^n 크기)하고
  - 모든 key의 해시값을 새 배열에 맞게 다시 계산하고 그에 따라 충돌을 처리함
  - 계산된 값에 따라 기존 엔트리를 모두 새 배열에 이동시킨 후 기존 배열을 삭제

- **Q2-5. 2^n scale로 resize된다고 했는데, 2^n+1의 배열 크기를 만들어도 부족해서 더 키워야 할 만큼의 요소가 한 번에 늘어나면 여러 차례 resizing을 반복하지 않고 바로 2^n+m의 resize를 수행하겠지?**

  - 물론 그렇지. 일반적인 경우를 생각해서 2^n+1을 반복하며 늘어난다고 설명했지만

  - 실제로는 요청된 최소 크기 이상을 만족하는 k를 선택해서 2^k 크기로 resize하는 로직임

    

- **Q3-1. 충돌은 어떻게 해결하나?**

  - open adressing
    - 충돌 발생시 빈 슬롯 탐색
    - python은 그 중에서도 선형탐사, 즉 원래 배정된 인덱스의 옆을 순차적으로 탐색하며 빈 슬롯을 찾아나가는 방식을 선택함
      - 단순 선형탐사만 하는 건 아니고, `compact probing`이라고 해서 여러 최적화 기법이 포함돼있긴 함
  - chaining
    - 배정된 인덱스에 리스트 형식으로 여러 key-value 쌍을 연쇄적으로 저장함

- **Q3-2. 그럼 chaining 방식을 쓴다고 했을 때, 하나의 버킷 인덱스에 단일 key-value 쌍만 저장되는 경우 튜플 하나만 들어가고 하나가 더 들어오는 순간 리스트를 생성해서 재할당하는 건가?**

  - 그건 알고리즘마다 다름. 처음부터 리스트 만들고 그 안에 튜플 하나만 저장할 수도 있고, 네 말대로 튜플 하나만 저장해놨다가 같은 인덱스에 값이 두 개가 되는 순간 리스트를 만드는 방식도 있고..
  - 근데 이건 python에서 쓰는 방식은 아니니까 분리해서 생각할 것.

- **Q3-3. 하나의 버킷 인덱스에 값이 하나일 때 튜플 하나만 넣으면 항목이 하나인 경우의 연산량을 줄이는 효과가 있고, 대신에 항목이 두 개 이상 생길 때마다 새 변수를 생성하고 그 안에 기존에 있던 튜플까지 다시 넣어야 하는 중복연산이 일어나는 trade-off가 있어서 그런 거지? 그렇다면 load factor가 높을수록 리스트를 미리 만들어놓는 방식이 유리하겠는데?**

  - 두 질문 다 맞음. 그 균형을 고려해서 설계해야 함.

    

- **Q4. mutable한 객체라고 하더라도, 해시값을 동적으로 연산해서 재할당하는 방식이라면 hashable하게 만들 수 있겠네?**

  - 맞긴 한데, 해시테이블 자체가 빠른 삽입/수정/조회를 위한 구조인데 그 방식은 성능을 엄청 깎음

  - 구조가 복잡해지고 실시간성이 요구되면 동기화 이슈 등 버그 발생 위험이 커짐

  - 그래서 mutable하면서 hashable한 객체를 만들 수 있긴 해도 안 쓰는 것이 관례

    

- **Q5. 파이썬 키고 아무 것도 안하면 해시테이블 크기가 얼마야? key-value쌍의 데이터가 하나도 없을 때도 미리 만들어두긴 하나?**
  - 해시테이블은 dict나 set같은 자료구조가 생성될 때 만들어지는 거니까 아무 것도 안 하면 당연히 없음
  - 다만 빈 dict(or set)라도 생기면, 이후 작업에 대한 성능 최적화를 위해 크기 8인 배열을 생성함



## 감상

- 파고 들면서 추론하며 배우니까 아주 꿀잼이다.
- 이런 데서 전공자들이랑 차이가 나겠구나 싶다. 이렇게 내부구조를 이해하고 있어야 코드 최적화를 하겠지.. 갈 길이 멀다.