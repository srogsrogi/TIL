# Object Oriented Programming

## 절차지향 | 객체지향

### 절차 지향

- 함수와 로직 중심 작성
- 데이터를 순차적으로 처리
- 프로그램 규모가 커질수록 유지보수가 어려움
  - 전역변수의 증가
  - 코드 수정시 영향 범위 파악이 어려움

### 객체 지향

- 데이터(변수)와 그 데이터를 처리하는 함수(메서드)를 하나의 단위(객체)로 묶어서 관리
- 데이터와 메서드의 결합
- 클래스는 설계도, 인스턴스는 그 설계도로 만든 물건으로 비유
  - 인스턴스끼리 같은 설계도를 공유해도 서로 다른 속성을 가질 수 있음

- 객체가 스스로 기능을 수행할 수 있게 되면서 코드의 재사용성이 높아지고 실제 세계와 유사한 모델링이 가능해짐

#### ※ 절차 지향과 객체 지향은 대조되는 개념이 아니다

- 객체 지향은 절차 지향을 기반으로 두고 보완하기 위해 나타난 패러다임

  

## 클래스

### 인스턴스 변수(속성)

- 각 인스턴스별 고유하고 독립적인 속성
- `self.변수명` 형태로 정의
- 클래스 변수와 같은 이름으로 정의하면, 섀도잉되어 더이상 그 클래스 변수에 접근할 수 없게 됨

### 클래스 변수(속성)

- 모든 인스턴스가 공유하는 속성
- 클래스 내부에서 직접 정의



## 메서드

### 인스턴스 메서드

- 클래스 메서드의 기본
- 반드시 첫 번째 인자로 인스턴스 자신(self)을 받음
  - `lst.append(A)`처럼 쓸 때는 잘 모르지만..
  - 인스턴스 메서드를 사용할 때, 실제 내부동작은 `list.append(lst, A)`이런 식
  - 즉 메서드는 클래스에서 사용되고, 그 인자로서 인스턴스 자체가 들어갈 수밖에 없다.

### 생성자 메서드

- `def __init__(self, ...)`
- 인스턴스가 생성될 때 자동으로 호출됨
  - 인스턴스 변수들의 초기값을 설정
- 초기값이 필요 없으면 안 써도 인터프리터가 알아서 생성자 만들어서 작동함
  - 그러나 코드스타일상 `pass`로 비워둔 생성자라도 그냥 명시적으로 써놓는게 좋음

### 클래스 메서드

- `@classmethod`데코레이터를 사용하여 정의
- 첫 번째 인자로 해당 메서드를 호출하는 클래스 자신(cls)이 전달됨

### 스태틱 메서드

- `@staticmethod`데코레이터를 사용하여 정의
- 클래스 및 인스턴스와 독립적으로 동작하는 메서드
- 클래스가 호출하여 사용하는 메서드
- 호출시 자동으로 전달받는 인자가 없음
- 클래스 및 인스턴스 속성에 직접 접근하지 않는 도우미 함수 같은 역할



### ※ 메서드 호출시 주의사항

- 원래 클래스는 클래스 메서드와 스태틱 메서드를 사용하고
- 인스턴스는 인스턴스 메서드만 사용해야 함
- 그런데 실제로 파이썬은 클래스든 인스턴스든 모든 메서드를 사용하는 데에 제약을 두지 않음
- 즉 아무렇게나 써도 동작은 하지만, 반드시 규칙을 지켜서 써야 혼란이 없음



## 질문/답변

- **Q1. init처럼 자동호출되는 매직메서드도 상위에 어떤 클래스에서 정의된 메서드겠네? 그럼 내가 파이썬에서 생성하는 모든 클래스는 그 상위 클래스의 인스턴스라고 볼 수 있는 건가?** 
  - 맞음. 매직메서드의 호출 주체는 메타클래스(주로 type)
  - 즉 우리가 만드는 모든 클래스는 type의 인스턴스고, 일반적으로 object 클래스를 상속한다.

- **Q2. python에서 클래스에 의해 만들어지지 않는 객체가 있긴 한가? 그냥 변수에 어떤 자료형이든 할당하면 그 자료형을 정의하는 클래스의 인스턴스잖아.**
  - 그치. 거의 모든 객체는 어떤 클래스의 인스턴스가 맞음
  - 인스턴스가 아닌 객체는 인터프리터 레벨에서 C로 만들어지는 type, object 클래스 정도 있음
  - 그래서 인스턴스에 대해서 얘기할 때는 **어떤 클래스의 인스턴스인지**를 함께 얘기해줘야 좀더 의미가 있음

- **Q3-1. 데코레이터가 정확히 뭘 말하는 거야?**
  - 다른 함수를 인자로 받아서 새로운 함수를 반환하는 함수
  - 어떤 함수의 코드를 유지한 채로 수정하거나 확장하기 위해 사용
- **Q3-2. 그럼 왜 스태틱 메서드랑 클래스 메서드 쓸 때만 데코레이터를 쓰는 거지?**
  - python 인터프리터 레벨에서의 설계임.
    - 클래스 내에서 메서드의 생성 규칙은 기본적으로 첫 번째 인자를 self로 받는 인스턴스 메서드에 맞춰져 있음
    - 그런데 클래스 메서드는 첫 번째 인자로 self가 아니라 cls를 받아와야 하고, 스태틱 메서드는 아예 자동으로 인자를 받아오지 않기 때문에 그 생성규칙에 어긋남
    - 그래서 python이 미리 만들어둔 @staticmethod, @classmethod 데코레이터를 통해서 바인딩 규칙만 변환해주는 거임



## 소감

- 처음 OOP 배웠을 땐 진짜 멀게 느껴졌는데 다시 들으니까 좀 정리가 됨
- 당장 자유자재로 쓰진 못하겠는데 무슨 말인지는 드디어 다 이해했다..
- 전에 텍스트 기반 로그라이트 게임 만들 때 클래스 구조 만들면서도 이해를 잘 못 했는데 다시 보면 할 수 있을 것 같다.
- 이제 클래스 내부의 각 변수나 메서드 동작할 때 디버깅도 예전보다 훨씬 자유롭게 해낼 수 있을 듯