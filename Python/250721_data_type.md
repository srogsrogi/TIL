# Data type

https://www.notion.so/SSAFY-bc6a721139f14e0c8de66459a7fd7ddc?p=2377a051cee68007ad53c94c98fc40e5&pm=s

## 연산자 우선순위

- 18개 연산자에 대한 우선순위가 정해져 있는데, 다 외울 필요는 당연히 없음

- 정확하게 작동하는 것도 중요하지만, 다른 사람이 코드를 봤을 때 직관적으로 이해할 수 있도록 ()를 이용하여 작성

  

## 정수형의 n진법 표현

- 2진수 : 0b

- 8진수 : 0o

- 16진수 : 0x

  ```python
  print(0b1011) # 11 -> 십진수로 변환됨
  ```



## 부동소수점 오차

- 컴퓨터는 모든 수를 2진수로 변환하여 저장

- 10진수 소수 중 일부(0.1 등)는 2진수로 변환했을 경우 무한소수가 됨

- 실제로 값을 저장할 때는 근사한 실수를 사용할 수밖에 없고, 그 결과 연산시 오차 발생

  ```python
  result = 0.1 + 0.2
  print(result == 0.3) # False
  print(result) # 0.300000000000004
  ```

- 정확하게 계산하고 싶으면 decimal.Decimal을 쓰거나
- 10^n 곱해서 정수로 연산한 후 다시 10^n으로 나누거나 하면 됨



## 질문/답변

- **1-1. 순환하지 않는 무한소수를 변수에 할당하려고 하면 어떻게 되지? 그냥 가능한 자리수까지만 들어가고 float으로 처리되려나?**

  - 맞음. 64비트 IEEE-754 표준에 따라 소수점 이하 15~17자리의 근사치로 들어감.

  - 더 정확하게 쓰고 싶으면 decimal을 써서 더 정밀한 근사치를 사용할 수도 있고

  - sympy를 써서 루트2, 파이 같은 기호를 유지하는 것도 가능


- **1-2. sympy로 기호를 유지하면 그 값 가지고 연산을 할 수가 있어? 어차피 연산할 때는 float처럼 처리하는 수밖에 없는 거 아니야?**

  - 아님. sympy는 값으로 연산하는게 아니라 수학적 형태 자체를 조작 및 정리하는 방식으로 계산하기 때문에 오차 없이 계산 가능.

  - 원하는 단계까지 symbolic 계산을 한 후, 현실에서 사용하는 등 실제 값이 필요한 경우 마지막 단계에서만 float으로 근사해서 쓰는 거.


- **1-3. 시퀀스 데이터는 순서가 있잖아. 그럼 시퀀스 데이터가 물리적으로 메모리에 저장될 때 각 인덱스에 있는 값이 서로 다른 위치에 저장되는 건가?**

  - 자료형에 따라 다름. str이나 arr은 연속된 블록에 저장되지만 list나 tuple은 그렇지 않음

  - 리스트나 튜플은 안에 있는 요소들은 따로 저장되고, 리스트(튜플) 자체는 그 요소들을 참조하는 형태로 저장됨.


- 2-1. 리스트든 튜플이든 배열이든 문자열이든 메모리상 비슷한 위치에 있어야 효율적인 거 아냐? 왜 문자열과 배열은 완전히 연속된 형태로 저장되고 리스트와 튜플은 그렇지 않은 거야?

  - 가까이 저장돼있으면 캐싱할 때 효율이 좋아지는 건 맞는데..

  - 요소들의 크기와 type이 다 다를 수 있으니까 연속해서 묶을 수가 없음

  - `[1, ‘hello’, [a,b,c], False]` 이런 걸 어떻게 묶겠어


- 2-2. 문자열 내의 개별 요소에 대한 할당이 불가능한 것도, immutable한 성질도 모두 메모리에 연속된 자리에 저장되는 것과 관련이 있는 거지?

  - 맞음. 이유를 쭉 정리해보면..

  - 연속된 메모리 블록에 한번에 할당하기 때문에 뭐 하나라도 바꾸려면 전체를 새로 만들어야 함

  - dict가 내부적으로 hash값을 통해 key를 검색하기 때문에  문자열이 key로 사용되려면 hashable해야 함

  - immutable해야 연산시 재사용, 캐싱하는 속도가 더 빠름