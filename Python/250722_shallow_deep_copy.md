# 참조 복사 | 얕은 복사 | 깊은 복사



## 참조복사(단순 할당)

```python
a = [1, 2, 3]
b = a
a.append(4)
print(b) # [1, 2, 3, 4]
```

```python
a = [1, 2, 3]
b = a
a += [4]
print(b) # [1, 2, 3, 4]
```

- `b = a` 처럼 할당하면, b는 a의 값이 아니라 참조하고 있는 주소를 할당받는다.

- a에 어떤 조작을 하면 b에도 그대로 적용됨

  - 참조하는 주소가 같기 때문에 반대로 b에 어떤 조작을 해도 a에도 그대로 적용됨
  - 즉, a든 b든 inplace 연산이 일어나는 한 반대쪽에도 당연히 영향을 미치고
  - inplace 연산이 아니어서 메모리 주소 자체가 새로 할당되는 경우에만 참조가 끊어진다.

- a = [1, 2, 3, 4] 이런 식으로 아예 재할당하면 a가 바라보는 참조는 바뀌지만, b는 이전에 할당받은 시점에 a가 가리키던 주소를 그대로 참조하기 때문에 b는 변하지 않는다.

  

## 얕은 복사

- 객체의 최상위 요소만 새로운 메모리에 복사

- 얕은 복사 구현 방법

  - copy

    ```python
    import copy
    a = [[1,2,3], [4,5,6]]
    b = copy.copy(a)
    a[0][2] = '삼'
    print(b) # [[1, 2, '삼'],[4, 5, 6]]
    ```

  - 리스트 슬라이싱

    ```python
    a = [1, 2, 3]
    b = a[:]
    ```

  - list 함수 사용

    ```python
    a = [1, 2, 3]
    b = list(a)
    ```

- 얕은 복사는 중첩 구조에서 각 요소의 주소를 참조하여 복사하기 때문에, mutable한 요소의 값이 변하면 복사본의 값도 변한다.

- 얕은복사 후 복사본에 append, remove, pop 등 리스트 겉 구조를 바꾸는 메소드들을 사용해도 원본에 영향을 주지 않는다.

- 요소가 immutable 객체일 경우 얕은 복사든 깊은 복사든 결과값이 같기 때문에 메모리 효율성을 높이기 위해 얕은 복사를 쓰도록 한다.

  

## 깊은 복사

```python
a = [[1,2,3], [4,5,6]]
b = copy.deepcopy(a)
a[0][2] = '삼'
print(b) # [[1,2,3],[4,5,6]]
```

- 깊은 복사는 복사하는 순간 내부에 있는 모든 요소의 값을 재귀적으로 복사하기 때문에 원본과는 완전히 분리된 객체가 된다.



## 요약

- 참조 복사는 같은 객체를 바라보는 것이고,
- 얕은 복사는 겉만 새로 만들고 내부는 공유하며,
- 깊은 복사는 내부까지 통째로 복제해서 완전히 독립된 객체를 만든다.



## 감상

- 어렴풋이만 알던 개념을 확실하게 이해하게 되었다.
- 다른 친구한테 설명해주면서 나도 조금씩 헷갈리던 부분을 바로잡을 수 있었다.