# list_2



## 부분집합

- 부분집합의 개수는 공집합을 포함해서 2^n개

- 각 원소의 포함 여부를 이진수로 표현한 비트 배열을 만들 수 있음

- bit = [0,1,0,0,1,1,1,0...] 이런 식이면 0자리 원소는 포함되지 않고 1자리 원소는 포함된 부분집합인 것

  ```python
  arr = [1, 2, 3]  # 부분집합을 구할 원소 리스트
  n = len(arr)
  
  for i in range(1 << n):  # 0부터 2^n - 1까지 반복
      subset = []
      for j in range(n):   # 각 자리수 검사
          if i & (1 << j): # j번째 비트가 1이면, 원소 포함
              subset.append(arr[j])
      print(subset)
  ```

  

## 선택정렬

- 반복적으로 가장 작은 값을 선택해서 가장 앞쪽에 순차적으로 배치하는 정렬 방법

- 리스트를 정렬된 구역과 정렬되지 않은 구역으로 나누고, 정렬되지 않은 구역에서의 최소값을 정렬된 구역의 맨 뒤 인덱스로 보내기를 반복함

- 시간복잡도는 O(n^2)

  ```python
  def selection_sort(a, N):
      for i in range(N-1):
          min_idx = i # 첫 원소를 기준값으로 설정
          for j in range(i+1, N):
              if a[min_idx] > a[j]: # 기준값보다 작은 값을 만나는 경우
                  min_idx = j # 최소값 인덱스 갱신
          a[i], a[min_idx] = a[min_idx], a[i] # 최소값을 맨 앞 인덱스의 값과 교환
  ```

  

## 이진 검색	

- 정렬된 리스트의 가운데에 있는 값을 기준으로 비교하여 그 결과에 따라 매 반복마다 탐색 구간을 절반으로 줄여나가는 방식

- up&down 게임과 비슷함

- 시간복잡도는 최대 O(log N)

  ```python
  def binarySearch(a, N, key):
      start = 0
      end = N - 1
      while start <= end:
          middle = (start + end) // 2
          if a[middle] == key: # 검색 성공
              return middle
          elif a[middle] > key: # 찾는 값보다 큰 경우
              end = middle - 1 # 검색 구간 변경
          else: # 찾는 값보다 작은 경우
              start = middle + 1 # 검색 구간 변경
      return -1 # 끝까지 못 찾으면 검색 실패
  ```

- Q1. 구간을 2분할하지 않고 3분할, 4분할 하는 방법은 어떨까? 한 번에 여러 값 비교하면 반복문 도는 횟수 자체는 줄일 수 있잖아.

  - 구간을 k분할하면, 반복 횟수는 log_k n의 scale로 줄어듦 
  - 반면 비교해야 하는 횟수는 k-1로, 선형 scale로 늘어남
  - 즉 k = 2일 때가 최적이다.

  - 3분 탐색이 쓰이는 경우도 있긴 한데..
    - 디스크 접근의 비용이 높은 특수한 환경에서 한 번에 많은 데이터를 읽고 처리하기 위해 사용하거나
    - 함수의 극값을 찾는 문제(기울기가 양수, 음수, 0인 구간/점을 탐색해야 하므로)에서는 효율적
