# 컴퓨터적 사고



## 직관 | 논리

### 직관

- 직관은 빠르지만 정확하지 않음
- 논리적인 느낌을 주면서 강한 착각을 주기 때문에 위험

### 논리

- 명제의 참/거짓이나 수식 등을 바탕으로 한 hard logic

#### 예시

```markdown
0이 홀수면 ~> 미국에서 2080년 월드컵이 열린다.

p가 거짓이니까 결과는 무조건 T
```



```markdown
만약 19893827938274839가 소수라면 ~> 2는 짝수이다.

(대우) 2가 짝수가 아니라면 19893827938274839는 소수가 아니다.

q가 참이니까 결과는 무조건 T
대우의 p가 거짓이니까 결과는 무조건 T
```

#### 논리적 증명의 방법

- 직접 증명(대입 등)
- 간접 증명(대우 등)
- 귀납
- ...



##### 떠오른 직관을 가지고 코딩을 시작하는 게 아니라, 명확한 논리 구조로 변환한 후에 코딩을 시작해야 한다!



## 알고리즘 문제 해결 과정

- 문제를 읽고 이해한다.
- 문제를 익숙한 나만의 용어로 재정의한다.
- 어떻게 문제를 해결할지 계획을 세운다. 자연어와 슈도 코드!!
  - 알고리즘을 생각하고 시간복잡도를 계산
    - 완전탐색을 먼저 생각한다.
    - 단순 완탐으로 안 되면 가지치기를 시도
    - 그 정도로 해결될 문제가 아니면 규칙 찾기를 시도(greedy 등)
    - greedy가 안 되면 DP로 또 넘어간다든지..
    - 일단 완탐을 생각해봐야 어느 부분이 시간/공간복잡도 이슈를 크게 일으키는지가 보이고 그에 따라 다음 전략을 정할 수 있다.
  - 총 시간이 얼마나 걸리고 문제 조건에 맞을지도 미리 계산해봐야 함
  - 코테 환경에서는.. 1초당 연산량이 C언어 계열은 1억 회, python은 3천만 회 정도로 잡는 편임
- 계획을 검증한다.
- 프로그램을 구현한다.
- 테스트
  - 주어진 tc도 input.txt에 넣어서 테스트해보고..
  -  hidden test case도 직접 생각해서 넣어봐야 하고..



##### 이해 및 설계에 전체 시간의 절반 가량을 쓰게 되는 것이 정상. 제대로 된 설계라면, 좀만 연습하면 구현은 금방 끝난다.



### Greedy로 풀 수 있는 조건

- Greedy는 구현은 쉬운데 규칙성과 논리를 명확히 하기가 어려운 방법

- 보통 완탐 먼저 할지 DP로 할지 Greedy로 할지를 많이 헷갈리는데.. 왕도가 있는 건 아니고, 많이 겪어봐야 함

- 다만 greedy로 풀 수 있는 두 가지 조건을 논리적으로 접근하는 연습을 해야 함



- 탐욕적 선택 조건(Greedy Choice Property)
  - 각 단계의 최적해 선택이 이후 단계 선택에 영향을 주지 않아야 한다.
  - 즉, 각 단계의 규칙이 변경되면 안 된다.
- 최적 부분 구조(Optimal Substructure)
  - 각 단계의 최적해 선택을 합하면, 전체 문제의 최적해가 되어야 한다.
    - 논리적 증명을 통해 검증해야 한다.



- 거스름돈 문제 예시
  - [명제] 가장 큰 동전부터 고르면 최소 동전 수가 나온다.
  - [간접 증명(귀류)] 최적해보다 더 적은 동전으로 표현 가능하다(가정).
    - N원을 더 작은 값의 동전을 사용해서 더 적은 동전 수로 표현할 수 있다.
    - 동전이 10, 50, 100... 상호간 배수 관계이기 때문에 더 적은 값으로 나누면 무조건 더 큰 수가 나온다.
    - 모순 발생 -> 원래 명제가 참
