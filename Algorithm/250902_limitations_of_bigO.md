# Big-O notation의 한계



## 질문

- 알고리즘 짜면서, 시간복잡도 맨날 n이니 n^2이니 하면서 계수나 상수항을 무시하는 big-O 표기법을 쓰잖아.
- n이 무한대로 발산한다는 가정 하에 그렇게 쓰는 것 같은데, 실제로는 당연히 입력값이 그보다는 훨씬 작은 실수범위 내에 있을 거란 말이지.
- 가령 `n^2 - 1000n`은 시간복잡도가 n^2이고, `5n`은 시간복잡도가 n이지만 어지간한 n값에서는 뒤에꺼가 훨씬 빨리 끝날테니까.. 이런 것도 좀 고려한 설계가 필요하지 않을까?



## Gemini와 대화

- 그래서 Big-O 말고도 시간복잡도를 표기하는 많은 방법들이 있기는 한데..
- 직관적으로만 이해하기보다 실례를 들어서 직접 계산을 해보자.

```
(n > 0)
algo A : n^2 + 1000n
algo B : 0.5n^3 + 10n^2
```

- 작은 n값에서는 algo B가 나을 거고, 클수록 algo A가 나아질테니까
- 둘을 같게 하는 n값을 찾으면 되겠지.
- 양변 n으로 나누고 근의공식으로 이차방정식 풀면 n = 36.xx가 나오니까, n이 37 이상일 때 algoA를 써야 한다는 명확한 결론을 도출할 수 있음.



##### 그리고..

- 식과 n값까지 같다고 할지라도, 실제로는 캐시/메모리 지역성, 분기 예측, 병렬화, 컴파일러와 인터프리터 버전에 따라 성능이 달라짐
- 사전적으로 계산을 하든, 벤치마크 테스트를 하든 입력값에 따른 성능을 미리 예측하고 분기를 나눌 수 있고, 관련 모듈들도 많으니 갖다 쓰면 된다! 



## 결론

- Big-O notation으로는 우월한 알고리즘이, 실제 환경에서의 우월성을 담보하지는 않는다.
- 시간복잡도가 다른 여러 알고리즘을 개발하고 들어오는 n값에 따라 더 효율적인 알고리즘을 선택하여 실행하도록 설계할 수 있다.

- 알고리즘 문제풀이할 때는 어차피 최악의 케이스를 상정해서 Big-O로 계산하는게 일반적이지만, 실제 서비스를 구현한다면 고려해야 할만한 문제이다.



## 소감

- Gemini `가이드 학습` 기능 들어왔대서 써봤는데 약~간 과하게 step by step으로 질문하는 경향이 있긴 하지만 대체로 학습하기 좋게 잘 알려준다.

- 처음에 갑자기 3차방정식 풀어보라길래 굳이 해야 하나 싶었는데 그래도 시키는대로 해봤더니 좀 더 오래 기억에 남을 것 같다.
- 직관적으로는 너무 당연한 이야기였는데 그걸 수식과 함께 명확한 논리로 접근해보지는 못한 것 같아 정리해봤더니 뭔가 말끔해진 느낌이 난다. 공부를 이렇게 해야 하는 것 같다.